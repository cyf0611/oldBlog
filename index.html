<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

</head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/avatar.jpg">
              </div>
		
		<div class="header-div">
		    <h1><a href="/">Hexo</a></h1>
		    <h2><a href="/"></a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href=""><i class="fa fa-book"></i>电子书</a>
		    		
		    		  <a href="http://cyf0611.pw"><i class="fa fa-user"></i>我的简历</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		      <a href=""><i class="fa fa-rss"></i>订阅</a>
		    
		      <a href=""><i class="fa fa-question-circle"></i>留言</a>
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper">
    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-03-24T07:30:52.000Z"><a href="/2017/03/24/border-none与border-0的区别/">2017-03-24</a></time>
        
  
    <h1 class="title"><a href="/2017/03/24/border-none与border-0的区别/">border:none与border:0的区别</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#性能差异："><span class="toc-text">性能差异：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#兼容性差异："><span class="toc-text">兼容性差异：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista-的XP主题下均会出现此情况。"><span class="toc-text">兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista 的XP主题下均会出现此情况。</span></a></li></ol></li></ol>
    </div>

        <h3 id="性能差异："><a href="#性能差异：" class="headerlink" title="性能差异："></a>性能差异：</h3><p>【border:0;】把border设为“0”像素虽然在页面上看不见，但按border默认值理解，浏览器依然对border-width/border-color进行了渲染，即已经占用了内存值</p>
<p>【border:none;】把border设为“none”即没有，浏览器解析“none”时将不作出渲染动作，即不会消耗内存值。</p>
<h3 id="兼容性差异："><a href="#兼容性差异：" class="headerlink" title="兼容性差异："></a>兼容性差异：</h3><h4 id="兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista-的XP主题下均会出现此情况。"><a href="#兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista-的XP主题下均会出现此情况。" class="headerlink" title="兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista 的XP主题下均会出现此情况。"></a>兼容性差异只针对浏览器IE6、IE7与标签button、input而言，在win、win7、vista 的XP主题下均会出现此情况。</h4><p>【border:none;】当border为“none”时对IE6/7无效,边框依然存在</p>
<p>【border:0;】当border为“0”时，感觉比“none”更有效，所有浏览器都一致把边框隐藏</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/03/24/border-none与border-0的区别/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-03-16T05:30:05.000Z"><a href="/2017/03/16/JSONP的优缺点/">2017-03-16</a></time>
        
  
    <h1 class="title"><a href="/2017/03/16/JSONP的优缺点/">JSONP的优缺点及原理</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-优点"><span class="toc-text">1.优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-缺点"><span class="toc-text">2.缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-原理"><span class="toc-text">3.原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#交互模型"><span class="toc-text">交互模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后台实现原理（以NodeJS为例）"><span class="toc-text">后台实现原理（以NodeJS为例）</span></a></li></ol>
    </div>

        <h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a><strong>1.优点</strong></h3><ul>
<li>它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略；</li>
<li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持</li>
<li>在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方。这个就相当于将controller层和view层终于分开了。我提供的jsonp服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续view操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个jsonp服务。</li>
</ul>
<h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a><strong>2.缺点</strong></h3><ul>
<li>它只支持GET请求而不支持POST等其它类型的HTTP请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
<li>jsonp在调用失败的时候不会返回各种HTTP状态码。</li>
<li>缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个 jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的。</li>
</ul>
<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a><strong>3.原理</strong></h3><h5 id="交互模型"><a href="#交互模型" class="headerlink" title="交互模型"></a><strong>交互模型</strong></h5><ol>
<li>利用 script 标签发请求</li>
<li>在客户端定义全局函数接收请求的结果数据</li>
<li>由服务器对发送的数据做包装处理 p</li>
<li>客户端收到响应的数据解析（调用提前定义好的函数）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function jsonp(options) &#123;</div><div class="line">        1. 创建 script 标签</div><div class="line">        2. 为 script 标签指定请求路径</div><div class="line">        3. 上 DOM，由浏览器去帮你解析处理发请求</div><div class="line">        4. 请求响应成功，执行 options 中的 success 指定的回调处理函数</div><div class="line"></div><div class="line">        var script = document.createElement(&apos;script&apos;)</div><div class="line"></div><div class="line">        var callbackName = &apos;itcast_&apos; + Math.random().toString().substr(2)</div><div class="line"></div><div class="line">        这里将参数选项中的 success 挂载给全局的 window 对象</div><div class="line">        当服务端响应回来的数据解析执行的时候，就要调用这个全局函数 window.callback</div><div class="line">        调用 window.callback 其实就相当于调用了 options.success</div><div class="line">        服务端响应了一个类似于这样的代码：itcast_1561561(数据)</div><div class="line">        window[callbackName] = function (data) &#123;</div><div class="line">            options.success(data)</div><div class="line">            document.body.removeChild(script) // 删除生成的 script 标签</div><div class="line">            delete window[callbackName] // 删除全局的回调处理函数</div><div class="line">        &#125;</div><div class="line">        //判断是否传入了查询字符串</div><div class="line">        if (options.url.indexOf(&apos;?&apos;)) &#123;</div><div class="line">            script.src = options.url + &apos;&amp;callback=&apos; + callbackName</div><div class="line">        &#125;else &#123;</div><div class="line">            script.src = options.url + &apos;?callback=&apos; + callbackName</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        这里只是把 script 标签上到了 DOM 中，并不是即时的发请求或者调用 success 回调处理函数</div><div class="line">        document.body.appendChild(script)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="后台实现原理（以NodeJS为例）"><a href="#后台实现原理（以NodeJS为例）" class="headerlink" title="后台实现原理（以NodeJS为例）"></a>后台实现原理（以NodeJS为例）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1.导包</div><div class="line">const express = require(&apos;express&apos;);</div><div class="line">const bodyParser = require(&apos;body-parser&apos;)</div><div class="line"></div><div class="line">2.创建App</div><div class="line">const app = express();</div><div class="line"></div><div class="line">app.get(&apos;/jsonpLogin&apos;,(req,res)=&gt;&#123;</div><div class="line">	const result = &#123;status:1,message:&quot;登录成功&quot;&#125;</div><div class="line">	const callbackFunc = req.query.callback;</div><div class="line">	if (req.query.username!=&apos;zhangsan&apos; || req.query.password!=&apos;123&apos;)&#123;</div><div class="line">		result.status = 0;</div><div class="line">		result.message = &quot;用户名或密码失败&quot;</div><div class="line">	&#125;</div><div class="line">	const resultJSONStr = JSON.stringify(result);</div><div class="line">	res.end(`$&#123;callbackFunc&#125;($&#123;resultJSONStr&#125;)`);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/03/16/JSONP的优缺点/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-03-15T14:41:40.000Z"><a href="/2017/03/15/AngularJS疑惑解答/">2017-03-15</a></time>
        
  
    <h1 class="title"><a href="/2017/03/15/AngularJS疑惑解答/">Angular疑惑解答</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ng-show-ng-hide-与-ng-if的区别？"><span class="toc-text">1.ng-show/ng-hide 与 ng-if的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-解释下什么是-rootScrope以及和-scope的区别？"><span class="toc-text">2.解释下什么是$rootScrope以及和$scope的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-angular-的数据绑定采用什么机制？详述原理-重点"><span class="toc-text">3.angular 的数据绑定采用什么机制？详述原理?(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？"><span class="toc-text">4.ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？</span></a></li></ol>
    </div>

        <h3 id="1-ng-show-ng-hide-与-ng-if的区别？"><a href="#1-ng-show-ng-hide-与-ng-if的区别？" class="headerlink" title="1.ng-show/ng-hide 与 ng-if的区别？"></a>1.ng-show/ng-hide 与 ng-if的区别？</h3><p>我们都知道ng-show/ng-hide实际上是通过display来进行隐藏和显示的。而ng-if实际上控制dom节点的增删除来实现的。因此如果我们是根据不同的条件来进行dom节点的加载的话，那么ng-if的性能好过ng-show.</p>
<h3 id="2-解释下什么是-rootScrope以及和-scope的区别？"><a href="#2-解释下什么是-rootScrope以及和-scope的区别？" class="headerlink" title="2.解释下什么是$rootScrope以及和$scope的区别？"></a>2.解释下什么是$rootScrope以及和$scope的区别？</h3><p>通俗的说$rootScrope 页面是所有$scope的父亲。</p>
<p>我们来看下如何产生$rootScope和$scope吧。</p>
<p>step1:Angular解析ng-app然后在内存中创建$rootScope。</p>
<p>step2:angular回继续解析，找到{…}表达式，并解析成变量。</p>
<p>step3:接着会解析带有ng-controller的div然后指向到某个controller函数。这个时候在这个controller函数变成一个$scope对象实例。</p>
<h3 id="3-angular-的数据绑定采用什么机制？详述原理-重点"><a href="#3-angular-的数据绑定采用什么机制？详述原理-重点" class="headerlink" title="3.angular 的数据绑定采用什么机制？详述原理?(重点)"></a>3.angular 的数据绑定采用什么机制？详述原理?(重点)</h3><p><strong>脏检查机制。</strong></p>
<p>双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。</p>
<p>原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。</p>
<h3 id="4-ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？"><a href="#4-ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？" class="headerlink" title="4.ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？"></a>4.ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？</h3><p>会提示 Duplicates in a repeater are not allowed. 加 <strong>track by $index</strong> 可解决。</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/03/15/AngularJS疑惑解答/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-03-14T13:55:46.000Z"><a href="/2017/03/14/MVC与MVVM总结/">2017-03-14</a></time>
        
  
    <h1 class="title"><a href="/2017/03/14/MVC与MVVM总结/">MVC与MVVM总结</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么会出现-MVVM-呢？"><span class="toc-text">为什么会出现 MVVM 呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么前端要工程化，要使用MVC？"><span class="toc-text">为什么前端要工程化，要使用MVC？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM-的出现，完美解决了以上三个问题"><span class="toc-text">MVVM 的出现，完美解决了以上三个问题</span></a>
    </div>

        <p>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的<strong>数据双向绑定</strong>。</p>
<h4 id="为什么会出现-MVVM-呢？"><a href="#为什么会出现-MVVM-呢？" class="headerlink" title="为什么会出现 MVVM 呢？"></a>为什么会出现 MVVM 呢？</h4><p>我接触MVVM 是在2015年，可以说2015年是MVVM 最火热的一年，而在这之前，我所知道的就是MVC,  MVC 大约是在5年前，也就是2011年的时候接触的，那时候刚学编程语言，学的Java，而Java 中经典的 SSH 框架就用来构建一个标准的MVC 框架。说实话，MVC 用了这么多年，但始终没有很深刻的理解，只停留在用的层面， 一直到接触 Vue.js 之后，研究了MVVM 架构思想，然后再回头看 MVC ，才有一种豁然开朗的感觉~</p>
<p>MVC 即 Model-View-Controller 的缩写，就是 <strong>模型-视图-控制器</strong> , 也就是说一个标准的Web 应用程式是由这三部分组成的： </p>
<blockquote>
<p><strong>View</strong> 用来把数据以某种方式呈现给用户。</p>
<p><strong>Model</strong> 其实就是数据。</p>
<p><strong>Controller</strong> 接收并处理来自用户的请求，并将 Model 返回给用户。</p>
</blockquote>
<p> 在HTML5 还未火起来的那些年，MVC 作为Web 应用的最佳实践是OK 的，这是因为 Web 应用的View 层相对来说比较简单，前端所需要的数据在后端基本上都可以处理好，View 层主要是做一下展示，那时候提倡的是 Controller 来处理复杂的业务逻辑，所以View 层相对来说比较轻量，就是所谓的瘦客户端思想。</p>
<p> 2010年到2011年，HTML5概念被热炒，受到追捧，2012年，W3C 正式宣布HTML5规范已经正式定稿。2013年我刚进公司就接触了第一个 HTML5 框架 Sench touch, 它是一款用来构建移动应用的HTML5 框架，它将前后端彻底分离，前端采用MVC 架构，作为一个独立的项目工程来维护。</p>
<h4 id="为什么前端要工程化，要使用MVC？"><a href="#为什么前端要工程化，要使用MVC？" class="headerlink" title="为什么前端要工程化，要使用MVC？"></a>为什么前端要工程化，要使用MVC？</h4><p> 相对 HTML4 , HTML5 最大的亮点是它为移动设备提供了一些非常有用的功能，使得 HTML5 具备了开发App的能力, HTML5开发App 最大的好处就是跨平台、快速迭代和上线，节省人力成本和提高效率，因此很多企业开始对传统的App进行改造，逐渐用H5代替Native，到2015年的时候，市面上大多数App 或多或少嵌入都了H5 的页面。</p>
<p> 既然要用H5 来构建 App, 那View 层所做的事，就不仅仅是简单的数据展示了，它不仅要管理复杂的数据状态，还要处理移动设备上各种操作行为等等。因此，前端也需要工程化，也需要一个类似于MVC 的框架来管理这些复杂的逻辑，使开发更加高效。 但这里的 MVC 又稍微发了点变化：</p>
<blockquote>
<p><strong>View</strong> UI布局，展示数据。</p>
<p><strong>Model</strong> 管理数据。</p>
<p><strong>Controller</strong> 响应用户操作，并将 Model 更新到 View 上。</p>
</blockquote>
<p> 这种 MVC 架构模式对于简单的应用来看起是OK 的，也符合软件架构的分层思想。 但实际上，随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：</p>
<ul>
<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>
<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li><p>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</p>
<p>其实，早期jquery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。</p>
</li>
</ul>
<h3 id="MVVM-的出现，完美解决了以上三个问题"><a href="#MVVM-的出现，完美解决了以上三个问题" class="headerlink" title="MVVM 的出现，完美解决了以上三个问题"></a>MVVM 的出现，完美解决了以上三个问题</h3><p> MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。</p>
<p> 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p> ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/03/14/MVC与MVVM总结/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="svn">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-03-11T13:18:00.000Z"><a href="/2017/03/11/使用方法/">2017-03-11</a></time>
        
  
    <h1 class="title"><a href="/2017/03/11/使用方法/">使用方法</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        
      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/03/11/使用方法/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-02-18T05:20:30.000Z"><a href="/2017/02/18/关于函数命名的只读性/">2017-02-18</a></time>
        
  
    <h1 class="title"><a href="/2017/02/18/关于函数命名的只读性/">关于函数命名的只读性</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>####看题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b = 1;</div><div class="line">(function b() &#123;</div><div class="line">    b = 2;</div><div class="line">    console.log(b);</div><div class="line">&#125;)();</div><div class="line">console.log(b);</div></pre></td></tr></table></figure></p>
<p>#####答案是多少？大部分人会说2和1，但是答案是：<br><code>function b(){
                                b=2;
                                console.log(b)
                            }</code> 和 1  。</p>
<p>为什么呢？下面来分析下。</p>
<p>对于第二次打印的结果，比较容易回答，这里用到了自执行函数和闭包，就不详细解释了。总的来说就是函数外层的console访问不到函数内部的变量，所以只能是1。<br>对于第一次打印的结果，这里运用到了函数声明，先来讲解下什么是<strong>函数声明</strong>和<strong>函数表达式</strong>：</p>
<p>####函数声明：<br>关于函数声明的方式,它的一个重要的特性就是函数声明提升（function declaration hoisting）,意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。像下面这样的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function b() &#123;</div><div class="line">        b = 2;</div><div class="line">        console.log(b);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>####函数表达式：<br>函数表达式有多种表达方式，下面是最常见的一种，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var b =function () &#123;</div><div class="line">        b = 2;</div><div class="line">        console.log(b);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>接下来继续说，由于此题的变量没有带var，即没有变量的声明，也就没有变量作用域的提升，只是单纯的赋值。也不存在函数声明的提升，闭包的影响。下面到重点了，如果在函数内部加上<strong>“use strict”（开启严格模式）</strong> 这句话，就会出现另外一个现象<br><em>这是火狐的报错:TypeError: “b” is read-only</em></p>
<p>意思就是说b是一个只读属性，此时b指的是函数的名字，不能被修改，所以报错了。</p>
<p><strong>补充：</strong> 今天又看到了一个例子，也是这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">b = function c() &#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line">    c = 3;</div><div class="line">    console.log(c);</div><div class="line">&#125;;</div><div class="line">b();</div></pre></td></tr></table></figure></p>
<p><strong>注意：这种情况存在于自执行函数和函数声明及函数表达式混合的命名方式中。</strong></p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/02/18/关于函数命名的只读性/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-02-12T04:16:43.000Z"><a href="/2017/02/12/判断一个数组或者一个字符串中出现次数最多的项及其次数/">2017-02-12</a></time>
        
  
    <h1 class="title"><a href="/2017/02/12/判断一个数组或者一个字符串中出现次数最多的项及其次数/">判断一个数组或者一个字符串中出现次数最多的项及其次数</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>####先用一个字符串来做实验，判断“what are you”出现的最多次的字母和次数，直接上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> var str=&quot;what are you&quot;;</div><div class="line"> function unique(str) &#123;</div><div class="line">var obj=&#123;&#125;;//该变量的作用:用来存储字符串对应的次数:字符串---出现次数</div><div class="line"> //因为要找到每个字母出现了多少次,所以,要遍历该字符串</div><div class="line"> for(var i=0;i&lt;str.length;i++)&#123;</div><div class="line">     //判断,这个字母在键值对中是否存在,如果不存在,把这个字母加入到键值对中</div><div class="line">     //之后做为键,该键对应的值就是该字母出现的次数</div><div class="line">     var key=str[i];//key中存储的是每一个字符串</div><div class="line">     if(obj[key])&#123;//判断这个键值对中有没有这个键</div><div class="line">         obj[key]++;</div><div class="line">     &#125;else&#123;</div><div class="line">         obj[key]=1;//obj[w]=1</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> //找到出现次数最多的字符串,及次数</div><div class="line"> var maxCount=0;//假设是出现次数最多的次数</div><div class="line"> var maxString=&quot;&quot;;//假设这个字符串是次数出现最多的字符串</div><div class="line"> for(var key in obj)&#123;</div><div class="line">     if(maxCount&lt;obj[key])&#123;</div><div class="line">         maxCount=obj[key];//保存最大的次数</div><div class="line">         maxString=key;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> return &quot;该字母:&quot;+maxString+&quot;出现了&quot;+maxCount+&quot;次&quot;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>####结果为：该字母：a出现了2次</p>
<p>那么如果是一个数组，该如何实现呢？其实实现代码一模一样。因为字符串也拥有数组的一些方法特性，比如length，str[i]等。只需直接调用封装的方法unique(arr)即可，如果想要结果更加清晰些，将return 的汉字换成出现最多的项是。。这样就行了。</p>
<blockquote>
<p>扩展：<br>   大家想一下，如果想要查询某个字母出现了多少次，如何实现呢？</p>
</blockquote>
<p>####可以将此功能分为两种：</p>
<ul>
<li>输入一个字符串或者字母，不传参情况应输出该字符串或字母的出现次数最多的项及其次数</li>
<li>传参的时候，应输入该查询字母或者数字出现了多长次，默认为0。</li>
</ul>
<p>实现代码，只是相比上面的代码调节了下return的部分，其他没变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var str=&quot;what are you&quot;;</div><div class="line">   function unique(str,value) &#123;</div><div class="line">       var obj=&#123;&#125;;//该变量的作用:用来存储字符串对应的次数:字符串---出现次数</div><div class="line">       //因为要找到每个字母出现了多少次,所以,要遍历该字符串</div><div class="line">       for(var i=0;i&lt;str.length;i++)&#123;</div><div class="line">           //判断,这个字母在键值对中是否存在,如果不存在,把这个字母加入到键值对中</div><div class="line">           //之后做为键,该键对应的值就是该字母出现的次数</div><div class="line">           var key=str[i];//key中存储的是每一个字符串</div><div class="line">           if(obj[key])&#123;//判断这个键值对中有没有这个键</div><div class="line">               obj[key]++;</div><div class="line">           &#125;else&#123;</div><div class="line">               obj[key]=1;//obj[w]=1</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       //找到出现次数最多的字符串,及次数</div><div class="line">       var maxCount=0;//假设是出现次数最多的次数</div><div class="line">       var maxString=&quot;&quot;;//假设这个字符串是次数出现最多的字符串</div><div class="line">       for(var key in obj)&#123;</div><div class="line">           if(maxCount&lt;obj[key])&#123;</div><div class="line">               maxCount=obj[key];//保存最大的次数</div><div class="line">               maxString=key;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       if (value) &#123;</div><div class="line">           if (obj[value]) &#123;</div><div class="line">               return &quot;该字母:&quot;+value+&quot;出现了&quot;+obj[value]+&quot;次&quot;;</div><div class="line">           &#125;</div><div class="line">           return &quot;该字母:&quot;+value+&quot;出现了&quot;+&quot;0次&quot;;</div><div class="line">       &#125;else &#123;</div><div class="line">           return &quot;该字母:&quot;+maxString+&quot;出现了&quot;+maxCount+&quot;次&quot;;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   console.log(unique(str,&quot;e&quot;));</div></pre></td></tr></table></figure>
<p><strong>此时打印结果：该字母：e出现了2次</strong></p>
<p>如果不传value值，输出仍然和扩展前的结果一样。</p>
<p>####另外一种新的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var names = [&apos;Alice&apos;, &apos;Bob&apos;, &apos;Tiff&apos;, &apos;Bruce&apos;, &apos;Alice&apos;];</div><div class="line"></div><div class="line">var countedNames = names.reduce(function (allNames, name) &#123; </div><div class="line">  if (name in allNames) &#123;</div><div class="line">    allNames[name]++;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    allNames[name] = 1;</div><div class="line">  &#125;</div><div class="line">  return allNames;</div><div class="line">&#125;, &#123;&#125;);</div><div class="line">// countedNames is:</div><div class="line">// &#123; &apos;Alice&apos;: 2, &apos;Bob&apos;: 1, &apos;Tiff&apos;: 1, &apos;Bruce&apos;: 1 &#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/02/12/判断一个数组或者一个字符串中出现次数最多的项及其次数/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-02-01T03:58:08.000Z"><a href="/2017/02/01/函数优先级大于变量优先级的深入探究————浏览器的预解析过程/">2017-02-01</a></time>
        
  
    <h1 class="title"><a href="/2017/02/01/函数优先级大于变量优先级的深入探究————浏览器的预解析过程/">函数优先级大于变量优先级的深入探究————浏览器的预解析过程</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>#函数优先级大于变量优先级的深入探究————<strong>浏览器的预解析过程</strong></p>
<p>###先由一道小题进入本文</p>
<pre><code>var foo;
function foo(){}
console.log(foo);
</code></pre><p>结果是函数体<strong><code>function foo(){}</code></strong><br>接着下面一道题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125;</div><div class="line">var foo;</div><div class="line">console.log(foo);</div></pre></td></tr></table></figure>
<p>结果也是函数体<strong><code>function foo(){}</code></strong></p>
<p>所有就有很多人说，函数声明的优先级大于变量声明的优先级。那么，为什么呢？这就要从浏览器的预解析说起了。</p>
<p>##预解析流程</p>
<ol>
<li>搜寻预解析关键字</li>
</ol>
<ul>
<li>寻找var关键字</li>
<li>寻找function关键字</li>
</ul>
<ol>
<li>执行预解析</li>
</ol>
<ul>
<li>先应用var关键字声明的标识符，使这些标识符有定义<ul>
<li>标识符有定以后，使用这项标识符就不会报错了</li>
<li>但因为没有赋值，因此其值为undefined</li>
</ul>
</li>
<li>至此标识符中保存了函数的引用</li>
</ul>
<p>###几个需要注意的细节</p>
<ul>
<li>var 关键字对同一个标识符重复使用时，除第一次有效外，其他均做忽略处理。</li>
<li>预解析时先处理变量声明，再处理函数声明</li>
<li>不要纠结谁的优先级高，这些只是表面现象</li>
<li>懂得了预解析流程，一切都是浮云</li>
</ul>
<p>看了预解析原理以后，下面咱们回到本文开头的两题，分析下预解析的过程，详细的了解为什么函数的优先级高于变量的优先级。follow me—-&gt;</p>
<p>先看第一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var foo;</div><div class="line">function foo()&#123;&#125;</div><div class="line">console.log(foo);</div></pre></td></tr></table></figure></p>
<p>预解析过程为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo;&lt;----变量声明的var</div><div class="line">var foo;&lt;----函数声明抽出的var</div><div class="line">foo=function ()&#123;&#125;&lt;----函数声明抽出的赋值</div><div class="line">console.log(foo);</div></pre></td></tr></table></figure></p>
<hr>
<p>再来看第二个,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125;</div><div class="line">var foo;</div><div class="line">console.log(foo);</div></pre></td></tr></table></figure></p>
<p>预解析过程为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo;&lt;----变量声明的var</div><div class="line">var foo;&lt;----函数声明抽出的var</div><div class="line">foo=function ()&#123;&#125;&lt;----函数声明抽出的赋值</div><div class="line">console.log(foo);</div></pre></td></tr></table></figure></p>
<p>比较这两个，你发现了什么？原来他们的预解析过程一样啊，这也就是为什么函数优先级高于变量的原因了。</p>
<hr>
<p>如果你理解了上面的内容，那么下面再出一个题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a=1;</div><div class="line">function a()&#123;&#125;</div><div class="line">console.log(a);</div></pre></td></tr></table></figure></p>
<p>这个浏览器是如何解析的呢？下面来跟着我的思路一起走：</p>
<ol>
<li>解析器首先搜寻var 关键字，结果第一行就发现了，把它提取到开头。</li>
<li>解析器搜寻function关键字，第二行发现了，首先分离var+函数名，此时发现和第一步的一样，不做处理，然后开始分离函数的赋值，也就是<code>a=function (){}</code>,此时a为函数体。</li>
<li>解析器接着处理变量的赋值，<code>a=1</code>，上一步的函数体被覆盖掉，此时a=1。</li>
<li>最后处理<code>console.log(a)</code>，自然而然的结果为1。</li>
</ol>
<p>下面是解析器处理的代码过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a;&lt;----变量声明的var</div><div class="line">var a;&lt;----函数声明抽出的var</div><div class="line">a=function ()&#123;&#125;&lt;----函数声明抽出的赋值</div><div class="line">a=1;</div><div class="line">console.log(a);</div></pre></td></tr></table></figure></p>
<hr>
<p><br></p>
<p>####先整理到这里，有什么错误和疑惑欢迎指出来。</p>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/02/01/函数优先级大于变量优先级的深入探究————浏览器的预解析过程/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-01-20T01:14:48.000Z"><a href="/2017/01/20/undefined与null的总结/">2017-01-20</a></time>
        
  
    <h1 class="title"><a href="/2017/01/20/undefined与null的总结/">undefined与null的总结</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>##二者区别</p>
<ul>
<li>null是一个表示“无”的对象，转为数值是0.</li>
<li>undefined是一个表示“无”的原始值，转换为数值是NaN.</li>
</ul>
<hr>
<p>###undefined的几种情况</p>
<ul>
<li>变量被声明，但是没有赋值，就等于undefined.</li>
<li>调用函数，应该传的参数没有传，此时该参数为undefined。</li>
<li>对象没有赋值的属性，为undefined.</li>
<li>函数没有返回值，默认返回undefined.</li>
</ul>
<hr>
<p>###null的几种情况</p>
<ul>
<li>作为原型链的最顶端，也就是<code>Object.prototype.__proto__</code>的指向。</li>
<li>作为函数的参数，表示该函数的参数不是对象。比如：<code>Math.min.apply(null,[21,5,1,5,-5,2])</code>，可以求得一个数组的最小值。</li>
</ul>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/01/20/undefined与null的总结/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




    <article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-01-12T02:19:01.000Z"><a href="/2017/01/12/http的各个状态码代表的意思/">2017-01-12</a></time>
        
  
    <h1 class="title"><a href="/2017/01/12/http的各个状态码代表的意思/">http的各个状态码代表的意思</a></h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <ul>
<li><strong>100</strong>，Continue  继续，一般在发送post请求时，已发送了http header之后服务器端将返回此信息，表示确认，之后发送具体参数信息。</li>
<li><strong>200</strong>，OK  正常返回信息。</li>
<li><strong>201</strong>，Created  请求成功并且服务器创建了新的资源。</li>
<li><strong>202</strong>，Accepted  服务器已接受请求，但尚未处理。</li>
<li><strong>301</strong>，Moved Permanently  请求的网页已永久移动到新位置。</li>
<li><strong>302</strong>，Found 临时性重定向。</li>
<li><strong>303</strong>，See Other  临时性重定向，且总是使用GET请求新的URL.</li>
<li><strong>304</strong>, Not Modified  自从上次请求过后，请求的网页未修改过。</li>
<li><strong>404</strong>，Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li><strong>401</strong>，Unauthorized  请求未授权。</li>
<li><strong>403</strong>，Forbidden  禁止访问。</li>
<li><strong>404</strong>，Not Found 找不到与URl相匹配的资源。</li>
<li><strong>500</strong>，Internal Service Error 最常见的服务器端错误。</li>
<li><strong>503</strong>，Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
<hr>
<p>####近期遇到过的：</p>
<ul>
<li>404 请求服务器获取不到相应资源，通常是url写错了</li>
<li>304 Not Modified 一般应用于加载过一次图片，再次刷新的时候，由于缓存，浏览器并未发送请求</li>
<li>416 Requested Range not satisfiable 官方解释是<strong>所请求的范围无法满足Web服务器，意思就是请求的数据超出了服务器相应的范围</strong>，实例：请求一个mp3文件，在服务器端虽然有mp3这个文件，但是这个文件里面没有数据，相当于无效</li>
</ul>

      
    </div>
    <footer>
      
        
        
        <div class="alignright">
          <a href="/2017/01/12/http的各个状态码代表的意思/#comment" class="comment-link">Comments</a>
        </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



 
<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
      <aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title" id="categories">分类</h3>
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ajax/">Ajax</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Angular/">Angular</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MV/">MV*</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RegExp/">RegExp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jQuery/">jQuery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/兼容/">兼容</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/SVN/">SVN</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/markdown/">markdown</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模块化/">模块化</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/模块化/SeaJS/">SeaJS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模块化/介绍/">介绍</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动WEB/">移动WEB</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网站相关/">网站相关</a><span class="category-list-count">3</span></li></ul> 
</div>
 


  <!--
<div class="widget tag">
  <h3 class="title">微信公众账号</h3>
    <ul class="entry">
      <img src="/img/default/qrcode.jpg" alt="欢迎关注，该账号供个人学习使用，偶尔做一些开发尝试，更新频率较低。" style= "width: 100%">
    </ul>
</div>-->


  <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>


  
<div class="widget">
  <h3 class="title">最新评论</h3>
  	<!-- 多说最新评论 start -->
	<div class="ds-recent-comments ds-recent-user" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
	<!-- 多说最新评论 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"lupeng-test"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
</div>



  


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Ajax/" style="font-size: 15px;">Ajax</a> <a href="/tags/Angular/" style="font-size: 15px;">Angular</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ES5/" style="font-size: 10px;">ES5</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML-SEO/" style="font-size: 10px;">HTML SEO</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JSONP/" style="font-size: 10px;">JSONP</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/RegExp/" style="font-size: 10px;">RegExp</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/SeaJS-模块化/" style="font-size: 10px;">SeaJS 模块化</a> <a href="/tags/canvas/" style="font-size: 10px;">canvas</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/link/" style="font-size: 10px;">link</a> <a href="/tags/load/" style="font-size: 10px;">load</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/window-document/" style="font-size: 10px;">window document</a> <a href="/tags/代理模式/" style="font-size: 10px;">代理模式</a> <a href="/tags/兼容性/" style="font-size: 10px;">兼容性</a> <a href="/tags/函数调用/" style="font-size: 10px;">函数调用</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/实例/" style="font-size: 10px;">实例</a> <a href="/tags/布局方式/" style="font-size: 10px;">布局方式</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/状态码/" style="font-size: 10px;">状态码</a> <a href="/tags/移动WEB/" style="font-size: 15px;">移动WEB</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/进制/" style="font-size: 10px;">进制</a> <a href="/tags/闭包/" style="font-size: 10px;">闭包</a> <a href="/tags/面向对象/" style="font-size: 10px;">面向对象</a> <a href="/tags/预解析/" style="font-size: 10px;">预解析</a>
  </div>
</div>


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">公元 2017 年</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">公元 2016 年</a><span class="archive-list-count">45</span></li></ul>
  </div>

</aside>
      <div class="clearfix"></div>
    </div>
  
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2017 John Doe
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>
  
  <div class="visit">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<!-- calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('undefined',{single:undefined, root:'calendar'});
    
    });
  </script>


<!-- 『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- wumii关联推荐 -->
<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>

<!-- 百度推荐 -->

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

<!-- 站内搜索-Swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','sC-iNFrvTTNtiXEVNwo1','2.0.0');
</script> -->

<!-- fancybox -->

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
